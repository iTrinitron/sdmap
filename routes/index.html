<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>CSE 198: Project</title>
		<author>Michael Chin</author>
	
		<!-- Raleway -->
		<link href='http://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
		
		<!-- Leaflet -->
		<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css" />
		<script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
		<!-- Jquery -->
		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

		<script src="http://d3js.org/d3.v3.min.js"></script>

		<style type="text/css">
			body {
				font-family: 'Raleway', sans-serif;
				background: #95a5a6;
			}

			#map { 
				height: 900px; 
			}
			#info { 
				height: 260px;
				background: #bdc3c7;
				border-radius: 30px;
				margin-top: 10px;
				padding: 20px;
			}
			
			#vertical-pane {
				position: relative;
				z-index: 3;
				float: right;
				height: 900px;
				width: 250px;
				padding: 10px 0px 10px 0px;
				background-color: rgba(189, 195, 199, 0.6);
			}
			
			#name {
				text-align: center;
				font-size: 30px;
			}
			
			#pie svg {
				display: block;
				margin-left: auto;
				margin-right: auto;
			}
			
			#click {
				text-align: center;
				background: #95a5a6;
				height: 25px;
				width: 100px;
				margin-left: auto;
				margin-right: auto;
				margin-top: 100px;
				line-height: 25px;
				font-size: 15px;
				cursor: pointer;
			}
			
			#hor-bar {
				width: 90%;
				margin-left: auto;
				margin-right: auto;
				height: 30px;
				background: #e74c3c;
				margin-top: 20px;
			}
			
			#hor-bar .mini-bar {
				height: 30px;
				float: left;
			}
		</style>
	</head>
	<body>
		<!-- Map -->
		<div id="map">
			
			<div id="vertical-pane">
				<div id="name">Region Name</div>
				<div id="pie">
				</div>
				<div id="hor-bar">
					<div class="mini-bar"></div>
				</div>
				<div id="click" onclick="updateSort()">
					Update Map
				</div>
			</div>
		</div>

		<script type="text/javascript">
			<!-- Load the database in -->
			//http://localhost:3000/db/language
			var localDB = [];
			loadData();
			var data;
			var currentSRA;
			
			
			//Create Map
			var map = L.map('map').setView([32.796968,-117.102807], 13);
			addMapbox();
			createLayer();
			loadMap();
			
			var myLayer;
			var mapData = [];
			
			function loadData() {
				$.ajax({
					dataType: "json",
					url: "db/language",
					success: function(data) {
						$(data).each(function(key, data) {
							if(localDB[data.SRA]) {
								localDB[data.SRA]["language"] = data
							}
							else {
								localDB[data.SRA] = [];
								localDB[data.SRA]["language"] = data
							}
						});
					}
				}).error(function() {}); 
				
				
				$.ajax({
					dataType: "json",
					url: "db/employment",
					success: function(data) {
						$(data).each(function(key, data) {
							if(localDB[data.SRA]) {
								localDB[data.SRA]["employment"] = data
							}
							else {
								localDB[data.SRA] = [];
								localDB[data.SRA]["employment"] = data
							}
						});
					}
				}).error(function() {}); 
			}
			
			
			
			function loadMap() {
				$.ajax({
					dataType: "json",
					url: "mapGeo/sandiego",
					success: function(data) {
						$(data.features).each(function(key, data) {

						//add data to map
							if(data.properties.popupContent == "La Jolla") {
								data.properties.class = "A";
							}

							addData(mapData); 
							myLayer.addData(data);
						});

					}
				}).error(function() {}); 
			}
			
			
			/*
			 * 
			 * I have to make all of my data changes in the ajax success -- apply all postgres then
			 * I cannot create a local storage of the mapdata or else GG no re
			 * -- system dies
			 * 
			 */
			
			
		
		function showMapData() {
			console.log("PRINT MAP DATA-----");
			console.log(mapData);
		}
		
		function updateSort() {
			//map.removeLayer(myLayer);
			myLayer.clearLayers();
			//change props
			if(mapData.properties.name == "La Jolla") {
				mapData.properties.class = "B";
			}
			
			createLayer();
			myLayer.addData(mapData);
			console.log("About to print map data");
		}

function addData(data) {
	//showMapData();
	myLayer.addData(data);
}

		function addStyle(feature) {
			var arraySize = Math.ceil(Math.random()*8);
			var fillColor = "#ff000" + arraySize;
			return { "weight": 1, "color": fillColor};
		}
		//popup = new L.Popup();

		/* WHEN WE CLICK THE MAP */
		function updateInfo(name, sra) {
			$('#name').html(sra + ": " + name);
			currentSRA = sra;

			
			
			boxUpdate();
			pieUpdate();
			
		}

		function onEachFeature(feature, layer) {
			// does this feature have a property named popupContent?
			if (feature.properties && feature.properties.name) {
				layer.bindPopup(feature.properties.name);
				layer.on("click", function (e) {
					var name = feature.properties.name;
					var sra = feature.properties.SRA;
					updateInfo(name, sra);
				});
			}
		}

		
function addMapbox() {
		L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
		attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
		maxZoom: 18,
		id: 'itrinitron.m79d7eg8',
		accessToken: 'pk.eyJ1IjoiaXRyaW5pdHJvbiIsImEiOiJ6NGNZaXVBIn0.1dTPdhyoMAUHkjX9wVl4eQ'
		}).addTo(map);
	}
		
		var myStyle = {
    "color": "#ff7800",
    "weight": 1,
    "opacity": 0.65
};


	function createLayer() {
		myLayer = L.geoJson(false, {
			style: function(feature) {
				switch (feature.properties.class) {
					case 'A': return {color: "#ff0000", weight: 1}; break;
					case 'B': return {color: "#00ff00", weight: 1}; break;
					default:   return {color: "#0000ff", weight: 1};
				}
			},
			onEachFeature: onEachFeature
		}).addTo(this.map);
	}

		/*
		map.on('click', function(e) {        
		var popLocation= e.latlng;
		var popup = L.popup()
		.setLatLng(popLocation)
		.setContent('<p>Hello world!<br />This is a nice popup.</p>')
		.openOn(map);        
		}); */


// MY PERSONAL BAR LINE
//<div class="mini-bar"></div>
	//console.log(localDB[sra]["employment"])
	
	function boxUpdate() {
		//Calculate the numbers
		var e = localDB[currentSRA]["employment"].employed;
		var ue  = localDB[currentSRA]["employment"].unemployed;
		var m = localDB[currentSRA]["employment"].military;
		total = e + ue + m;
		
		//employed, military, unemployed
		w1 = Math.ceil(e/total * 100);
		w2 = Math.floor(m/total * 100); 
		w3 = Math.floor(ue/total * 100);
		
		console.log(total);
		
		b1 = "#2ecc71";
		b2 = "#9b59b6";
		b3 = "#e74c3c";
	
		$('#hor-bar').html(' \
			<div class="mini-bar" style=" width: ' + w1 + '%; background: ' + b1 + ';"></div> \
			<div class="mini-bar" style=" width: ' + w2 + '%; background: ' + b2 + ';"></div> \
			<div class="mini-bar" style=" width: ' + w3 + '%; background: ' + b3 + ';"></div> \
		');
		
	}
		


		</script>
		
		<script>
		var w = 200;
var h = 100;
var r = 50; //radius
var ir = 0; //inner-radius
var textOffset = 14;
var tweenDuration = 250;

//OBJECTS TO BE POPULATED WITH DATA LATER
var lines, valueLabels, nameLabels;
var pieData = [];    
var oldPieData = [];
var filteredPieData = [];

//D3 helper function to populate pie slice parameters from array data
var donut = d3.layout.pie().value(function(d){
  return d.octetTotalCount;
});

//D3 helper function to create colors from an ordinal scale
var color = d3.scale.category20();

//D3 helper function to draw arcs, populates parameter "d" in path object
var arc = d3.svg.arc()
  .startAngle(function(d){ return d.startAngle; })
  .endAngle(function(d){ return d.endAngle; })
  .innerRadius(ir)
  .outerRadius(r);

///////////////////////////////////////////////////////////
// GENERATE FAKE DATA /////////////////////////////////////
///////////////////////////////////////////////////////////

var arrayRange = 100000; //range of potential values for each item
var arraySize;
var streakerDataAdded;

function fillArray() {
  return {
    port: "", //label
    octetTotalCount: Math.ceil(Math.random()*(arrayRange))
  };
}

///////////////////////////////////////////////////////////
// CREATE VIS & GROUPS ////////////////////////////////////
///////////////////////////////////////////////////////////

var vis = d3.select("#pie").append("svg:svg")
  .attr("width", w)
  .attr("height", h);

//GROUP FOR ARCS/PATHS
var arc_group = vis.append("svg:g")
  .attr("class", "arc")
  .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

//GROUP FOR LABELS
var label_group = vis.append("svg:g")
  .attr("class", "label_group")
  .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

//GROUP FOR CENTER TEXT  
var center_group = vis.append("svg:g")
  .attr("class", "center_group")
  .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

//PLACEHOLDER GRAY CIRCLE
var paths = arc_group.append("svg:circle")
    .attr("fill", "#EFEFEF")
    .attr("r", r);

///////////////////////////////////////////////////////////
// CENTER TEXT ////////////////////////////////////////////
///////////////////////////////////////////////////////////

//WHITE CIRCLE BEHIND LABELS
var whiteCircle = center_group.append("svg:circle")
  .attr("fill", "white")
  .attr("r", ir);

// "TOTAL" LABEL
/*
var totalLabel = center_group.append("svg:text")
  .attr("class", "label")
  .attr("dy", -15)
  .attr("text-anchor", "middle") // text-align: right
  .text("TOTAL"); */

/*
//TOTAL TRAFFIC VALUE /
var totalValue = center_group.append("svg:text")
  .attr("class", "total")
  .attr("dy", 7)
  .attr("text-anchor", "middle") // text-align: right
  .text("Waiting..."); 

//UNITS LABEL
var totalUnits = center_group.append("svg:text")
  .attr("class", "units")
  .attr("dy", 21)
  .attr("text-anchor", "middle") // text-align: right
  .text("kb");
*/

///////////////////////////////////////////////////////////
// STREAKER CONNECTION ////////////////////////////////////
///////////////////////////////////////////////////////////
dataCounter = -1;
function fillData() {
	dataCounter++;
	if(dataCounter == 0) {
		return {
			port: "English",
			octetTotalCount: localDB[currentSRA]["language"].english
		};
	}
	else if(dataCounter == 1) {
		return {
			port: "Spanish",
			octetTotalCount: localDB[currentSRA]["language"].spanish
		};
	}
	else if(dataCounter == 2) {
		return {
			port: "Asian",
			octetTotalCount: localDB[currentSRA]["language"].asian
		};
	}
}

// to run each time data is generated
function pieUpdate() {

  arraySize = 3
  streakerDataAdded = d3.range(arraySize).map(fillData);
  dataCounter = -1;
  oldPieData = filteredPieData;
  pieData = donut(streakerDataAdded);

  var totalOctets = 0;
  filteredPieData = pieData.filter(filterData);
  function filterData(element, index, array) {
    element.name = streakerDataAdded[index].port;
    element.value = streakerDataAdded[index].octetTotalCount;
    totalOctets += element.value;
    return (element.value > 0);
  }

  if(filteredPieData.length > 0 && oldPieData.length > 0){

    //REMOVE PLACEHOLDER CIRCLE
    arc_group.selectAll("circle").remove();

/*
    totalValue.text(function(){
      var kb = totalOctets/1024;
      return kb.toFixed(1);
      //return bchart.label.abbreviated(totalOctets*8);
    }); */

    //DRAW ARC PATHS
    paths = arc_group.selectAll("path").data(filteredPieData);
    paths.enter().append("svg:path")
      .attr("stroke", "white")
      .attr("stroke-width", 0.5)
      .attr("fill", function(d, i) { return color(i); })
      .transition()
        .duration(tweenDuration)
        .attrTween("d", pieTween);
    paths
      .transition()
        .duration(tweenDuration)
        .attrTween("d", pieTween);
    paths.exit()
      .transition()
        .duration(tweenDuration)
        .attrTween("d", removePieTween)
      .remove();

    //DRAW TICK MARK LINES FOR LABELS
    lines = label_group.selectAll("line").data(filteredPieData);
    lines.enter().append("svg:line")
      .attr("x1", 0)
      .attr("x2", 0)
      .attr("y1", -r-3)
      .attr("y2", -r-8)
      .attr("stroke", "gray")
      .attr("transform", function(d) {
        return "rotate(" + (d.startAngle+d.endAngle)/2 * (180/Math.PI) + ")";
      });
    lines.transition()
      .duration(tweenDuration)
      .attr("transform", function(d) {
        return "rotate(" + (d.startAngle+d.endAngle)/2 * (180/Math.PI) + ")";
      });
    lines.exit().remove();

    //DRAW LABELS WITH PERCENTAGE VALUES
    valueLabels = label_group.selectAll("text.value").data(filteredPieData)
      .attr("dy", function(d){
        if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
          return 5;
        } else {
          return -7;
        }
      })
      .attr("text-anchor", function(d){
        if ( (d.startAngle+d.endAngle)/2 < Math.PI ){
          return "beginning";
        } else {
          return "end";
        }
      })
      .text(function(d){
        var percentage = (d.value/totalOctets)*100;
        return percentage.toFixed(1) + "%";
      });

    valueLabels.enter().append("svg:text")
      .attr("class", "value")
      .attr("transform", function(d) {
        return "translate(" + Math.cos(((d.startAngle+d.endAngle - Math.PI)/2)) * (r+textOffset) + "," + Math.sin((d.startAngle+d.endAngle - Math.PI)/2) * (r+textOffset) + ")";
      })
      .attr("dy", function(d){
        if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
          return 5;
        } else {
          return -7;
        }
      })
      .attr("text-anchor", function(d){
        if ( (d.startAngle+d.endAngle)/2 < Math.PI ){
          return "beginning";
        } else {
          return "end";
        }
      }).text(function(d){
        var percentage = (d.value/totalOctets)*100;
        return percentage.toFixed(1) + "%";
      });

    valueLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

    valueLabels.exit().remove();


    //DRAW LABELS WITH ENTITY NAMES
    nameLabels = label_group.selectAll("text.units").data(filteredPieData)
      .attr("dy", function(d){
        if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
          return 17;
        } else {
          return 5;
        }
      })
      .attr("text-anchor", function(d){
        if ((d.startAngle+d.endAngle)/2 < Math.PI ) {
          return "beginning";
        } else {
          return "end";
        }
      }).text(function(d){
        return d.name;
      });

    nameLabels.enter().append("svg:text")
      .attr("class", "units")
      .attr("transform", function(d) {
        return "translate(" + Math.cos(((d.startAngle+d.endAngle - Math.PI)/2)) * (r+textOffset) + "," + Math.sin((d.startAngle+d.endAngle - Math.PI)/2) * (r+textOffset) + ")";
      })
      .attr("dy", function(d){
        if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
          return 17;
        } else {
          return 5;
        }
      })
      .attr("text-anchor", function(d){
        if ((d.startAngle+d.endAngle)/2 < Math.PI ) {
          return "beginning";
        } else {
          return "end";
        }
      }).text(function(d){
        return d.name;
      });

    nameLabels.transition().duration(tweenDuration).attrTween("transform", textTween);

    nameLabels.exit().remove();
  }  
}

///////////////////////////////////////////////////////////
// FUNCTIONS //////////////////////////////////////////////
///////////////////////////////////////////////////////////

// Interpolate the arcs in data space.
function pieTween(d, i) {
  var s0;
  var e0;
  if(oldPieData[i]){
    s0 = oldPieData[i].startAngle;
    e0 = oldPieData[i].endAngle;
  } else if (!(oldPieData[i]) && oldPieData[i-1]) {
    s0 = oldPieData[i-1].endAngle;
    e0 = oldPieData[i-1].endAngle;
  } else if(!(oldPieData[i-1]) && oldPieData.length > 0){
    s0 = oldPieData[oldPieData.length-1].endAngle;
    e0 = oldPieData[oldPieData.length-1].endAngle;
  } else {
    s0 = 0;
    e0 = 0;
  }
  var i = d3.interpolate({startAngle: s0, endAngle: e0}, {startAngle: d.startAngle, endAngle: d.endAngle});
  return function(t) {
    var b = i(t);
    return arc(b);
  };
}

function removePieTween(d, i) {
  s0 = 2 * Math.PI;
  e0 = 2 * Math.PI;
  var i = d3.interpolate({startAngle: d.startAngle, endAngle: d.endAngle}, {startAngle: s0, endAngle: e0});
  return function(t) {
    var b = i(t);
    return arc(b);
  };
}

function textTween(d, i) {
  var a;
  if(oldPieData[i]){
    a = (oldPieData[i].startAngle + oldPieData[i].endAngle - Math.PI)/2;
  } else if (!(oldPieData[i]) && oldPieData[i-1]) {
    a = (oldPieData[i-1].startAngle + oldPieData[i-1].endAngle - Math.PI)/2;
  } else if(!(oldPieData[i-1]) && oldPieData.length > 0) {
    a = (oldPieData[oldPieData.length-1].startAngle + oldPieData[oldPieData.length-1].endAngle - Math.PI)/2;
  } else {
    a = 0;
  }
  var b = (d.startAngle + d.endAngle - Math.PI)/2;

  var fn = d3.interpolateNumber(a, b);
  return function(t) {
    var val = fn(t);
    return "translate(" + Math.cos(val) * (r+textOffset) + "," + Math.sin(val) * (r+textOffset) + ")";
  };
}
		
		</script>
	</body>
</html>